[{"id":"65021a59a0d5eb977481013298cc8b80","title":"JS core简介","content":"JS coreGC机制：Tracing Garbage Collection从GCRoot维护的一条引用链，会清除引用链无法触达的地方\nJS Context熟悉js的人应该都知道，jsContext就是js执行的上下文环境，其中比较重要的一点就是全局的WIndow对象\nJSVirtualMachine（JSVM）JSVM是一个抽象的虚拟机。不同JSVM执行不同的任务，每个JSContext都从属于一个JSVM，每个JSVM都有自己独立的堆空间，GC也只能处理JSVM内部的对象，不同的JSVM之间无法进行传值。JSVM和JS Context之间的关系如下：\n\nJSExport实现JSExport协议可以开放OC类和它们的实例方法，类方法，以及属性给JS调用\nJSValueJSValue实例是一个指向JS值的引用指针。我们可以使用JSValue类，在OC和JS的基础数据类型之间相互转换。同时我们也可以使用这个类，去创建包装了Native自定义类的JS对象，或者是那些由Native方法或者Block提供实现JS方法的JS对象。\n总结JSCore给iOS App提供了JS可以解释执行的运行环境与资源。对于我们实际开发而言，最主要的就是JSContext和JSValue这两个类。JSContext提供互相调用的接口，JSValue为这个互相调用提供数据类型的桥接转换。让JS可以执行Native方法，并让Native回调JS，反之亦然。\n\n","slug":"JS core简介","date":"2022-05-05T11:31:52.948Z","categories_index":"JS原理","tags_index":"","author_index":"动物园园长"},{"id":"83828ee736bf235d7180bde42e5f781a","title":"Vue3异步组件的原理","content":"首先请参考Vue异步组件的用法\n1.用例分析此处写一个Vue异步组件的例子：\nVue.component('async-example', function (resolve, reject) &#123;\n  setTimeout(function () &#123;\n    // 向 `resolve` 回调传递组件定义\n    resolve(&#123;\n      template: '&lt;div>I am async!&lt;/div>'\n    &#125;)\n  &#125;, 1000)\n&#125;)\n可见此处传入了两个参数，一个是组件的名字，一个是工厂函数，工厂函数接受两个参数（resolve， reject），工厂函数会收到一个resolve回调，这个回调函数会在你从服务器得到组件定义的时候被调用。也可以调用reject(reason)来表示加载失败。不想这个异步组件实现的具体的逻辑，先考虑一下大方向：\n1.怎么判断这是一个异步组件\n2.在确定是异步组件以后，要调用异步函数来渲染和生成组件并将结果保存，并创建异步组件的占位符\n3.异步函数运行完以后，通过watcher来进行组件更新\n2.具体逻辑解释如果不是html标签，都会进入到createComponent函数中来创建VNode节点，那么异步组件肯定会进入到该函数中，该函数做三件事情\n1）判断组件函数，然后进入不同的函数来进行相应的逻辑处理，如果传入的参数是对象，则通过Ctor = baseCtor.extend(Ctor)构造子类构造函数，如果是函数，说明传入的是异步组件，则进入到resolveAsyncComponent函数中\n2）安装组件的钩子函数\n3）通过以上函数完成相应组件的配置，从而根据这些配置来实例化VNode节点\nfunction createComponent(\n        Ctor,\n        data,\n        context,\n        children,\n        tag\n    ) &#123;\n        if (isUndef(Ctor)) &#123;\n            return\n        &#125;\n        var baseCtor = context.$options._base;\n        // 自定义组件(异步组件除外)均会传入一个对象\n        if (isObject(Ctor)) &#123;\n            // 构造子类构造函数\n            Ctor = baseCtor.extend(Ctor);\n        &#125;\n        // 如果既不是对象也不是函数 则给出\"无效组件\"的提示\n        if (typeof Ctor !== 'function') &#123;\n            &#123;\n                warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n            &#125;\n            return\n        &#125;\n        var asyncFactory;\n        // 通过cid属性是否未定义来判断是否为异步组件\n        if (isUndef(Ctor.cid)) &#123;\n            asyncFactory = Ctor;\n            // 正式进入处理异步组件的函数\n            Ctor = resolveAsyncComponent(asyncFactory, baseCtor);\n            if (Ctor === undefined) &#123;\n                // 创建异步组件的占位符\n                return createAsyncPlaceholder(\n                    asyncFactory,\n                    data,\n                    context,\n                    children,\n                    tag\n                )\n            &#125;\n        &#125;\n        // 安装组件的钩子函数\n        installComponentHooks(data);\n        // return a placeholder vnode\n        var name = Ctor.options.name || tag;\n        // 创建VNode节点\n        var vnode = new VNode(\n            (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n            data, undefined, undefined, undefined, context,\n            &#123; Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children &#125;,\n            asyncFactory\n        );\n        return vnode\n    &#125;\n由于此处重点讲解异步组件的逻辑，那么就重点看下resolveAsyncComponent的逻辑，\nfunction resolveAsyncComponent(\n        factory,\n        baseCtor\n    ) &#123;\n        if (isTrue(factory.error) &amp;&amp; isDef(factory.errorComp)) &#123;\n            return factory.errorComp\n        &#125;\n        if (isDef(factory.resolved)) &#123;\n         // 此时返回缓存的组件\n            return factory.resolved\n        &#125;\nif (owner &amp;&amp; !isDef(factory.owners)) &#123;\n            var owners = factory.owners = [owner];\n            var sync = true;\n            var timerLoading = null;\n            var timerTimeout = null\n                ; (owner).$on('hook:destroyed', function () &#123; return remove(owners, owner); &#125;);\n            var forceRender = function (renderCompleted) &#123;\n                for (var i = 0, l = owners.length; i &lt; l; i++) &#123;\n                 // 触发组件强制更新的函数\n                    (owners[i]).$forceUpdate();\n                &#125;\n            &#125;;\n// 保证resolve函数只运行一次\nvar resolve = once(function (res) &#123;\n// 创建异步组件并保存在resolved中\nfactory.resolved = ensureCtor(res, baseCtor);\n// 如果不是同步的，则进行强制更新 \n                if (!sync) &#123;\n                    forceRender(true);\n                &#125; else &#123;\n                    owners.length = 0;\n                &#125;\n            &#125;);\n // 保证reject函数只运行一次\n            var reject = once(function (reason) &#123;\n                warn(\n                    \"Failed to resolve async component: \" + (String(factory)) +\n                    (reason ? (\"\\nReason: \" + reason) : '')\n                );\n                // 如果渲染错误切定义了加载失败的组件，则显示错误\n                if (isDef(factory.errorComp)) &#123;\n                    factory.error = true;\n                    forceRender(true);\n                &#125;\n            &#125;);\n            //执行工厂函数(异步函数)\n            var res = factory(resolve, reject);\n            if (isObject(res)) &#123;\n            // 如果函数返回的结果为一个promise对象\n                if (isPromise(res)) &#123;\n                    // () => Promise\n                    if (isUndef(factory.resolved)) &#123;\n                     // 如果加载成功运行定义的resolve函数\n                        res.then(resolve, reject);\n                    &#125;\n                &#125; \n            &#125;\n            sync = false;\n            // return in case resolved synchronously\n            return factory.loading\n                ? factory.loadingComp\n                : factory.resolved\n        &#125;\n    &#125;\n可见以上写法的逻辑已经梳理完毕了，但是还有高级异步组件的写法如下:\nconst AsyncComponent = () => (&#123;\n  // 需要加载的组件 (应该是一个 `Promise` 对象)\n  component: import('./MyComponent.vue'),\n  // 异步组件加载时使用的组件\n  loading: LoadingComponent,\n  // 加载失败时使用的组件\n  error: ErrorComponent,\n  // 展示加载时组件的延时时间。默认值是 200 (毫秒)\n  delay: 200,\n  // 如果提供了超时时间且组件加载也超时了，\n  // 则使用加载失败时使用的组件。默认值是：`Infinity`\n  timeout: 3000\n&#125;)\n可以看到多了很多配置条件，可以在异步的不同状态下分别加载不同的页面，然后可以看一下Vue是怎么处理这一块的逻辑。\nif (isObject(res)) &#123;\n  if (isPromise(res)) &#123;\n    // () => Promise\n    if (isUndef(factory.resolved)) &#123;\n      res.then(resolve, reject)\n    &#125;\n    // 如果component是promise对象\n  &#125; else if (isPromise(res.component)) &#123;\n    //加载异步组件成功的话进入resolve回调，失败的话进入reject回调\n    res.component.then(resolve, reject)\n    // 如果定义了error\n    if (isDef(res.error)) &#123;\n      // 调用ensureCtor方法传入错误组件和基本配置来创建组件并添加缓存\n      factory.errorComp = ensureCtor(res.error, baseCtor)\n    &#125;\n    // 如果定义了loading\n    if (isDef(res.loading)) &#123;\n      // 创建loading组件并加入缓存\n      factory.loadingComp = ensureCtor(res.loading, baseCtor)\n      // 如果没有设置delay的时间，直接设置loading的状态为true\n      if (res.delay === 0) &#123;\n        factory.loading = true\n      &#125; else &#123;\n        // 如果有delay的话，就用setTimeout函数使得在多少时间后触发强制更新来渲染loading组件\n        timerLoading = setTimeout(function () &#123;\n          timerLoading = null\n          if (isUndef(factory.resolved) &amp;&amp; isUndef(factory.error)) &#123;\n            factory.loading = true\n            // 强制更新并传入并未渲染完成的参数\n            forceRender(false)\n          &#125;\n        &#125;, res.delay || 200)\n      &#125;\n    &#125;\n    // 如果定义了timeout\n    if (isDef(res.timeout)) &#123;\n      timerTimeout = setTimeout(function () &#123;\n        timerTimeout = null\n        if (isUndef(factory.resolved)) &#123;\n          // 进入到reject回调函数 \n          reject('timeout (' + (res.timeout) + 'ms)')\n        &#125;\n      &#125;, res.timeout)\n    &#125;\n  &#125;\n&#125;","slug":"Vue异步组件逻辑","date":"2022-04-01T12:15:39.521Z","categories_index":"Vue","tags_index":"","author_index":"动物园园长"},{"id":"88c311ebad772fb24ed33c5c5f934d02","title":"Vue3调试环境准备","content":"Vue3调试环境准备1.克隆Vue3的代码git clone https://github.com/vuejs/vue-next.git\n\n2.安装依赖和打包yarn\nyarn dev\n\nyarn dev启动rollup将代码打包生成为vue.global.js，文件位置如图所示\n![image (1)](./image (1).png)\n3.新建demo页面，并在文件中引入vue.global.js文件![Screenshot 2021-02-19 at 5.36.13 PM](./Screenshot 2021-02-19 at 5.36.13 PM.png)\n此处贴上我的composition.html页面\n&lt;!DOCTYPE html>\n&lt;html lang=\"en\">\n\n&lt;head>\n    &lt;meta charset=\"UTF-8\">\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    &lt;title>Document&lt;/title>\n    &lt;script src=\"../../packages/vue/dist/vue.global.js\">&lt;/script>\n&lt;/head>\n\n&lt;body>\n    &lt;div id=\"event-handling\" class=\"demo\">\n        &lt;p>&#123;&#123; message &#125;&#125;&lt;/p>\n        &lt;button v-on:click=\"reverseMessage\">Reverse Message&lt;/button>\n    &lt;/div>\n&lt;/body>\n&lt;script>\n    const EventHandling = &#123;\n        data() &#123;\n            return &#123;\n                message: 'Hello Vue.js!'\n            &#125;\n        &#125;,\n        methods: &#123;\n            reverseMessage() &#123;\n                this.message = this.message\n                    .split('')\n                    .reverse()\n                    .join('')\n            &#125;\n        &#125;\n    &#125;\n\n    Vue.createApp(EventHandling).mount('#event-handling')\n&lt;/script>\n\n&lt;/html>\n\n4.添加SourceMap文件为了在浏览器能够查看源码和断点调试，可在rollup.config.js文件的createConfig函数中添加如下的命令，表示打包的时候会生成sourcemap文件用来记录函数的位置。\noutput.sourcemap &#x3D; true\n\n然后在在tsconfig.json中配置sourcemap输出\n&#123;\n  &quot;compilerOptions&quot;: &#123;\n    &quot;baseUrl&quot;: &quot;.&quot;,\n    &quot;outDir&quot;: &quot;dist&quot;,\n    &#x2F;&#x2F; 修改sourcemap文件的配置\n    &quot;sourceMap&quot;: true,\n    ...\n&#125;\n\n完成以上操作即可实现在浏览器断点调试了，如果想在vscode进行断点调试可参考以下操作\n5.修改.vscode的文件夹下面launch.json文件添加如下配置，并修改file的路径为html demo文件的路径\n\n\n最后点击左侧的run，然后点击调试Vue调用即可调起调试的页面，也可以在源码中打断点进行调试\n![Screenshot 2021-02-19 at 6.00.44 PM](./Screenshot 2021-02-19 at 6.00.44 PM.png)\n","slug":"Vue3调试环境准备","date":"2022-04-01T12:14:15.209Z","categories_index":"Vue","tags_index":"","author_index":"动物园园长"},{"id":"2a112d259007295f8e773659e0f0b890","title":"vue nextTick的原理","content":"Vue nextTick的原理使用方法在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM\n// 修改数据\nvm.msg = 'Hello'\n// DOM 还没有更新\nVue.nextTick(function () &#123;\n  // DOM 更新了\n&#125;)\n// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)\nVue.nextTick()\n  .then(function () &#123;\n    // DOM 更新了\n  &#125;)\n\n\n\n源码逻辑  Vue.nextTick在src/core/util/nextTick.js文件中，可以通过源码看出这个逻辑为，首先将回调函数加入到flushCallbacks队列中，如果监测到pending（是否正在执行）为false，则触发timerFun函数，来运行flushCallbacks队列中的回调函数。由于flushCallbacks队列中的回调函数是需要在DOM更新后执行的，那么有几种方法来实现这个想法。\n1.可以把回调函数放在微任务或者宏任务中运行，那样在DOM更新后才会运行这些回调函数，Vue也是首先进行了平台是否支持Promise的判断，如果支持则用promise.then()来执行队列中的回调函数\n2.判断浏览器是否支持MutationObserver ，如果支持就用MutationObserver监测DOM的更新状态，此时也是有个比较巧妙的做法是，新建了一个文本节点，当运行timerFun函数时则改变这个文本节点的值，那样MutationObserver监测到以后就运行队列中的回调函数\n3.判断平台是否支持setImmediate函数，通过setImmediate函数运行队列中的回调函数\n4.如果都不支持，则使用setTimeout宏任务来更新队列函数\n/* @flow */\n/* globals MutationObserver */\n\nimport &#123; noop &#125; from 'shared/util'\nimport &#123; handleError &#125; from './error'\nimport &#123; isIE, isIOS, isNative &#125; from './env'\n\nexport let isUsingMicroTask = false\n\nconst callbacks = []\nlet pending = false\n\nfunction flushCallbacks () &#123;\n  pending = false\n  const copies = callbacks.slice(0)\n  callbacks.length = 0\n  for (let i = 0; i &lt; copies.length; i++) &#123;\n  // 执行队列中的回调函数\n    copies[i]()\n  &#125;\n&#125;\n\nlet timerFunc\nif (typeof Promise !== 'undefined' &amp;&amp; isNative(Promise)) &#123;\n// 如果平台支持promise函数 则用promise执行任务队列\n  const p = Promise.resolve()\n  timerFunc = () => &#123;\n    p.then(flushCallbacks)\n    if (isIOS) setTimeout(noop)\n  &#125;\n  isUsingMicroTask = true\n&#125; else if (!isIE &amp;&amp; typeof MutationObserver !== 'undefined' &amp;&amp; (\n  // 如果浏览器支持MutationObserver 则用MutationObserver监测DOM的更新状态\n  isNative(MutationObserver) ||\n  // PhantomJS and iOS 7.x\n  MutationObserver.toString() === '[object MutationObserverConstructor]'\n)) &#123;\n  // 在浏览器中新建一个文本节点，然后通过观测文本节点的变化来决定监测DOM的更新状态\n  let counter = 1\n  const observer = new MutationObserver(flushCallbacks)\n  const textNode = document.createTextNode(String(counter))\n  observer.observe(textNode, &#123;\n    characterData: true\n  &#125;)\n  timerFunc = () => &#123;\n    counter = (counter + 1) % 2\n    textNode.data = String(counter)\n  &#125;\n  isUsingMicroTask = true\n&#125; else if (typeof setImmediate !== 'undefined' &amp;&amp; isNative(setImmediate)) &#123;\n  // 判断是否支持setImmediate函数\n  timerFunc = () => &#123;\n    setImmediate(flushCallbacks)\n  &#125;\n&#125; else &#123;\n  // 否则使用setTimeout来更新队列函数\n  // Fallback to setTimeout.\n  timerFunc = () => &#123;\n    setTimeout(flushCallbacks, 0)\n  &#125;\n&#125;\n\nexport function nextTick (cb?: Function, ctx?: Object) &#123;\n  let _resolve\n  // 把nextTick的回调函数加入到队列中，\n  callbacks.push(() => &#123;\n    if (cb) &#123;\n      try &#123;\n      // 执行回调函数\n        cb.call(ctx)\n      &#125; catch (e) &#123;\n        handleError(e, ctx, 'nextTick')\n      &#125;\n    &#125; else if (_resolve) &#123;\n      _resolve(ctx)\n    &#125;\n  &#125;)\n  if (!pending) &#123;\n    pending = true\n    timerFunc()\n  &#125;\n  // 当未传入回调函数时，提供一个promise的调用\n  if (!cb &amp;&amp; typeof Promise !== 'undefined') &#123;\n    return new Promise(resolve => &#123;\n      _resolve = resolve\n    &#125;)\n  &#125;\n&#125;\n\n\n\n","slug":"Vue nextTick的原理","date":"2022-04-01T12:06:02.451Z","categories_index":"Vue","tags_index":"","author_index":"动物园园长"},{"id":"0c8fa70d5490d97115738363a2ade7ea","title":"weex框架浅析","content":"1.跨端框架react-native、fluter和weexReact-native: 基于 js 引擎，通过 bridge 注入一些设备能力的 api，而渲染跨端则是使用安卓、ios 实现 react 的 virtual dom 的渲染。\nWeex: js框架更类似于vue，其他架构与RN类似，也是通过bridge向安卓和ios发送消息实现api的调用\nflutter: 渲染不是基于操作系统的组件，而是直接基于绘图库（skia）来绘制的，这样做到了渲染的跨端。逻辑的跨端也不是基于 js 引擎，而是自研的 dart vm 来跨端，通过 dart 语言来写逻辑\n![image-20211009164255894](/Users/shuanghuili/Library/Application Support/typora-user-images/image-20211009164255894.png)\n\n\n\n\nFlutter\nReact Native\n评价\n\n\n\n编程语言\nDart\nJS\nJS语言生态更好  Dart学习成本也不高，支持JIT与AOT\n\n\nNative通信\nSkia\nJavaScript-bridge\nRN在UI渲染路径较长  Flutter渲染性能在路径上堪比原生\n\n\nUI组件与API\nSDK\n框架（framework）\nFlutter：Material &amp; Cupertino &amp; testing  &amp;  navigation、包的尺寸更大  RN：Dependent  on 3rd-party libraries\n\n\n\n\n\n\n\n\n2.weex总体的框架图\nweex-Jsfm从一个简单的weex文件来讲解weex-jsfm做了哪些处理\n打包前的文件\n首先可以看一下框架的目录结构\n![截屏2021-10-09 下午5.20.43](/Users/shuanghuili/Library/Application Support/typora-user-images/截屏2021-10-09 下午5.20.43.png)\nentries首先第一步为初始化前端框架（Vue，Vanilla，Rax和 Weex），注册前端全局方法供框架使用\nimport &#123; freezePrototype &#125; from './env'\nimport setup from './setup'\nimport frameworks from '../frameworks'\n\nsetup(frameworks)\nfreezePrototype()\n\n再看下是如何setUp框架的呢，首先注册框架的信息，然后用init函数初始化框架的配置，最后将方法注册为全局API供框架使用。\nexport default function (frameworks) &#123;\n  const &#123; init, config &#125; = runtime\n  config.frameworks = frameworks\n  const &#123; native, transformer &#125; = subversion\n\n  for (const serviceName in services) &#123;\n    runtime.service.register(serviceName, services[serviceName])\n  &#125;\n\n  runtime.freezePrototype()\n\n  // register framework meta info\n  global.frameworkVersion = native\n  global.transformerVersion = transformer\n\n  // init frameworks\n  const globalMethods = init(config)\n\n  // set global methods\n  for (const methodName in globalMethods) &#123;\n    global[methodName] = (...args) => &#123;\n      const ret = globalMethods[methodName](...args)\n      if (ret instanceof Error) &#123;\n        console.error(ret.toString())\n      &#125;\n      return ret\n    &#125;\n  &#125;\n&#125;\n\n可以看到setup函数使用init函数来初始化框架，而init函数中使用initTaskHandler函数，这个函数初始化任务处理中心的方法，是brige/TaskCenter.js中的init函数\nexport default function init (config) &#123;\n  runtimeConfig = config || &#123;&#125;\n  frameworks = runtimeConfig.frameworks || &#123;&#125;\n  // 初始化任务处理中心\n  initTaskHandler()\n\n  // Init each framework by `init` method and `config` which contains three\n  // virtual-DOM Class: `Document`, `Element` &amp; `Comment`, and a JS bridge method:\n  // `sendTasks(...args)`.\n  for (const name in frameworks) &#123;\n    const framework = frameworks[name]\n    if (typeof framework.init === 'function') &#123;\n      try &#123;\n        framework.init(config)\n      &#125;\n      catch (e) &#123;&#125;\n    &#125;\n  &#125;\n\n  adaptMethod('registerComponents', registerComponents)\n  adaptMethod('registerModules', registerModules)\n  adaptMethod('registerMethods')\n\n  ; ['destroyInstance', 'refreshInstance'].forEach(genInstance)\n\n  return methods\n&#125;\n\nbrigejs与native侧通信的桥梁\n这个函数为TaskCenter类的原型上挂载了诸多对外的方法，这些方法最终是调用的原生方法处理。\nexport function init () &#123;\n  const DOM_METHODS = &#123;\n    createFinish: global.callCreateFinish,\n    updateFinish: global.callUpdateFinish,\n    refreshFinish: global.callRefreshFinish,\n\n    createBody: global.callCreateBody,\n\n    addElement: global.callAddElement,\n    removeElement: global.callRemoveElement,\n    moveElement: global.callMoveElement,\n    updateAttrs: global.callUpdateAttrs,\n    updateStyle: global.callUpdateStyle,\n\n    addEvent: global.callAddEvent,\n    removeEvent: global.callRemoveEvent,\n    __updateComponentData: global.__updateComponentData\n  &#125;\n  const proto = TaskCenter.prototype\n\n  for (const name in DOM_METHODS) &#123;\n    const method = DOM_METHODS[name]\n    proto[name] = method ?\n      (id, args) => method(id, ...args) :\n      (id, args) => fallback(id, [&#123; module: 'dom', method: name, args &#125;], '-1')\n  &#125;\n\n  proto.componentHandler = global.callNativeComponent ||\n    ((id, ref, method, args, options) =>\n      fallback(id, [&#123; component: options.component, ref, method, args &#125;]))\n\n  proto.moduleHandler = global.callNativeModule ||\n    ((id, module, method, args) =>\n      fallback(id, [&#123; module, method, args &#125;]))\n&#125;\n\n然后将这些方法应用到removeChild方法上，当我们调用元素removeChild方法的时候就会对应到taskCenter.send方法，讲需要发送的指令发送给客户端从而进行删除子元素的方法，而像这样写元素appendChild，insertBefore和insertAfter等方法的文件都在vdom文件夹里面。\n/**\n  * Remove a child node, and decide whether it should be destroyed.\n  * @param &#123;object&#125; node\n  * @param &#123;boolean&#125; preserved\n  */\n Element.prototype.removeChild = function removeChild (node, preserved) &#123;\n   if (node.parentNode) &#123;\n     removeIndex(node, this.children, true);\n     if (node.nodeType === 1) &#123;\n       removeIndex(node, this.pureChildren);\n       var taskCenter = getTaskCenter(this.docId);\n       if (taskCenter) &#123;\n         taskCenter.send(\n           'dom',\n           &#123; action: 'removeElement' &#125;,\n           [node.ref]\n         );\n       &#125;\n     &#125;\n   &#125;\n   if (!preserved) &#123;\n     node.destroy();\n   &#125;\n &#125;;\n\nvdomvirtual dom的实现，其中包括注释节点、weex元素，浏览器的document，自定义element节点。例如原生weex节点，就是直接向客户端发送消息来注册该元素。\nexport function registerElement (type, methods) &#123;\n  // Skip when no special component methods.\n  if (!Array.isArray(methods) || !methods.length) &#123;\n    return\n  &#125;\n\n  // Init constructor.\n  class WeexElement extends Element &#123;&#125;\n\n  // Add methods to prototype.\n  methods.forEach(methodName => &#123;\n    WeexElement.prototype[methodName] = function (...args) &#123;\n      const taskCenter = getTaskCenter(this.docId)\n      if (taskCenter) &#123;\n        return taskCenter.send('component', &#123;\n          ref: this.ref,\n          component: type,\n          method: methodName\n        &#125;, args)\n      &#125;\n    &#125;\n  &#125;)\n\n\n\n\n最后总结流程图如下\n以weex-vue-framework为例主要做了如下几件事：\n\ncreateInstanceContext\n创建实例，处理weex实例\n\ncreateVueModuleInstance\n创建Vue实例，并做对weex的适配\n\n挂载weex提供的api到Vue实例上，如document，taskCenter等\n\n当vue生成虚拟dom的时候就可以直接调用挂载在实例上的方法，进行组件的创建，然后向桥发送消息由客户端最终进行组件的创建\n\n\n![image-20211013194158430](/Users/shuanghuili/Library/Application Support/typora-user-images/image-20211013194158430.png)\n","slug":"weex","date":"2022-01-24T08:08:07.333Z","categories_index":"框架","tags_index":"","author_index":"动物园园长"},{"id":"645029120f6ca463868b24b968b5fc86","title":"自学前端进阶之路","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n```        \n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-01-24T06:59:38.347Z","categories_index":"","tags_index":"","author_index":"动物园园长"}]