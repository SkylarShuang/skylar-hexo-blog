[{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"world","date":"2022-01-24T08:08:13.849Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"0c8fa70d5490d97115738363a2ade7ea","title":"weex框架浅析","content":"1.跨端框架react-native、fluter和weexReact-native: 基于 js 引擎，通过 bridge 注入一些设备能力的 api，而渲染跨端则是使用安卓、ios 实现 react 的 virtual dom 的渲染。\nWeex: js框架更类似于vue，其他架构与RN类似，也是通过bridge向安卓和ios发送消息实现api的调用\nflutter: 渲染不是基于操作系统的组件，而是直接基于绘图库（skia）来绘制的，这样做到了渲染的跨端。逻辑的跨端也不是基于 js 引擎，而是自研的 dart vm 来跨端，通过 dart 语言来写逻辑\n![image-20211009164255894](/Users/shuanghuili/Library/Application Support/typora-user-images/image-20211009164255894.png)\n\n\n\n\nFlutter\nReact Native\n评价\n\n\n\n编程语言\nDart\nJS\nJS语言生态更好  Dart学习成本也不高，支持JIT与AOT\n\n\nNative通信\nSkia\nJavaScript-bridge\nRN在UI渲染路径较长  Flutter渲染性能在路径上堪比原生\n\n\nUI组件与API\nSDK\n框架（framework）\nFlutter：Material &amp; Cupertino &amp; testing  &amp;  navigation、包的尺寸更大  RN：Dependent  on 3rd-party libraries\n\n\n\n\n\n\n\n\n2.weex总体的框架图\nweex-Jsfm从一个简单的weex文件来讲解weex-jsfm做了哪些处理\n打包前的文件\n首先可以看一下框架的目录结构\n![截屏2021-10-09 下午5.20.43](/Users/shuanghuili/Library/Application Support/typora-user-images/截屏2021-10-09 下午5.20.43.png)\nentries首先第一步为初始化前端框架（Vue，Vanilla，Rax和 Weex），注册前端全局方法供框架使用\nimport &#123; freezePrototype &#125; from './env'\nimport setup from './setup'\nimport frameworks from '../frameworks'\n\nsetup(frameworks)\nfreezePrototype()\n\n再看下是如何setUp框架的呢，首先注册框架的信息，然后用init函数初始化框架的配置，最后将方法注册为全局API供框架使用。\nexport default function (frameworks) &#123;\n  const &#123; init, config &#125; = runtime\n  config.frameworks = frameworks\n  const &#123; native, transformer &#125; = subversion\n\n  for (const serviceName in services) &#123;\n    runtime.service.register(serviceName, services[serviceName])\n  &#125;\n\n  runtime.freezePrototype()\n\n  // register framework meta info\n  global.frameworkVersion = native\n  global.transformerVersion = transformer\n\n  // init frameworks\n  const globalMethods = init(config)\n\n  // set global methods\n  for (const methodName in globalMethods) &#123;\n    global[methodName] = (...args) => &#123;\n      const ret = globalMethods[methodName](...args)\n      if (ret instanceof Error) &#123;\n        console.error(ret.toString())\n      &#125;\n      return ret\n    &#125;\n  &#125;\n&#125;\n\n可以看到setup函数使用init函数来初始化框架，而init函数中使用initTaskHandler函数，这个函数初始化任务处理中心的方法，是brige/TaskCenter.js中的init函数\nexport default function init (config) &#123;\n  runtimeConfig = config || &#123;&#125;\n  frameworks = runtimeConfig.frameworks || &#123;&#125;\n  // 初始化任务处理中心\n  initTaskHandler()\n\n  // Init each framework by `init` method and `config` which contains three\n  // virtual-DOM Class: `Document`, `Element` &amp; `Comment`, and a JS bridge method:\n  // `sendTasks(...args)`.\n  for (const name in frameworks) &#123;\n    const framework = frameworks[name]\n    if (typeof framework.init === 'function') &#123;\n      try &#123;\n        framework.init(config)\n      &#125;\n      catch (e) &#123;&#125;\n    &#125;\n  &#125;\n\n  adaptMethod('registerComponents', registerComponents)\n  adaptMethod('registerModules', registerModules)\n  adaptMethod('registerMethods')\n\n  ; ['destroyInstance', 'refreshInstance'].forEach(genInstance)\n\n  return methods\n&#125;\n\nbrigejs与native侧通信的桥梁\n这个函数为TaskCenter类的原型上挂载了诸多对外的方法，这些方法最终是调用的原生方法处理。\nexport function init () &#123;\n  const DOM_METHODS = &#123;\n    createFinish: global.callCreateFinish,\n    updateFinish: global.callUpdateFinish,\n    refreshFinish: global.callRefreshFinish,\n\n    createBody: global.callCreateBody,\n\n    addElement: global.callAddElement,\n    removeElement: global.callRemoveElement,\n    moveElement: global.callMoveElement,\n    updateAttrs: global.callUpdateAttrs,\n    updateStyle: global.callUpdateStyle,\n\n    addEvent: global.callAddEvent,\n    removeEvent: global.callRemoveEvent,\n    __updateComponentData: global.__updateComponentData\n  &#125;\n  const proto = TaskCenter.prototype\n\n  for (const name in DOM_METHODS) &#123;\n    const method = DOM_METHODS[name]\n    proto[name] = method ?\n      (id, args) => method(id, ...args) :\n      (id, args) => fallback(id, [&#123; module: 'dom', method: name, args &#125;], '-1')\n  &#125;\n\n  proto.componentHandler = global.callNativeComponent ||\n    ((id, ref, method, args, options) =>\n      fallback(id, [&#123; component: options.component, ref, method, args &#125;]))\n\n  proto.moduleHandler = global.callNativeModule ||\n    ((id, module, method, args) =>\n      fallback(id, [&#123; module, method, args &#125;]))\n&#125;\n\n然后将这些方法应用到removeChild方法上，当我们调用元素removeChild方法的时候就会对应到taskCenter.send方法，讲需要发送的指令发送给客户端从而进行删除子元素的方法，而像这样写元素appendChild，insertBefore和insertAfter等方法的文件都在vdom文件夹里面。\n/**\n  * Remove a child node, and decide whether it should be destroyed.\n  * @param &#123;object&#125; node\n  * @param &#123;boolean&#125; preserved\n  */\n Element.prototype.removeChild = function removeChild (node, preserved) &#123;\n   if (node.parentNode) &#123;\n     removeIndex(node, this.children, true);\n     if (node.nodeType === 1) &#123;\n       removeIndex(node, this.pureChildren);\n       var taskCenter = getTaskCenter(this.docId);\n       if (taskCenter) &#123;\n         taskCenter.send(\n           'dom',\n           &#123; action: 'removeElement' &#125;,\n           [node.ref]\n         );\n       &#125;\n     &#125;\n   &#125;\n   if (!preserved) &#123;\n     node.destroy();\n   &#125;\n &#125;;\n\nvdomvirtual dom的实现，其中包括注释节点、weex元素，浏览器的document，自定义element节点。例如原生weex节点，就是直接向客户端发送消息来注册该元素。\nexport function registerElement (type, methods) &#123;\n  // Skip when no special component methods.\n  if (!Array.isArray(methods) || !methods.length) &#123;\n    return\n  &#125;\n\n  // Init constructor.\n  class WeexElement extends Element &#123;&#125;\n\n  // Add methods to prototype.\n  methods.forEach(methodName => &#123;\n    WeexElement.prototype[methodName] = function (...args) &#123;\n      const taskCenter = getTaskCenter(this.docId)\n      if (taskCenter) &#123;\n        return taskCenter.send('component', &#123;\n          ref: this.ref,\n          component: type,\n          method: methodName\n        &#125;, args)\n      &#125;\n    &#125;\n  &#125;)\n\n\n\n\n最后总结流程图如下\n以weex-vue-framework为例主要做了如下几件事：\n\ncreateInstanceContext\n创建实例，处理weex实例\n\ncreateVueModuleInstance\n创建Vue实例，并做对weex的适配\n\n挂载weex提供的api到Vue实例上，如document，taskCenter等\n\n当vue生成虚拟dom的时候就可以直接调用挂载在实例上的方法，进行组件的创建，然后向桥发送消息由客户端最终进行组件的创建\n\n\n![image-20211013194158430](/Users/shuanghuili/Library/Application Support/typora-user-images/image-20211013194158430.png)\n","slug":"weex","date":"2022-01-24T08:08:07.333Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n```        \n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-01-24T06:59:38.347Z","categories_index":"","tags_index":"","author_index":"Aurora"}]